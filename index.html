<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>3D English Learning Whack-a-Mole!（3D英語学習モグラたたき）</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'Arial', sans-serif; background: linear-gradient(135deg, #1e3c72, #2a5298); color: white; overflow: hidden; touch-action: manipulation; }
    #gameContainer { position: relative; width: 100vw; height: 100vh; }
    #threeCanvas { display: block; }
    .ui-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 100; }
    .ui-overlay > * { pointer-events: auto; }

    /* ステージ選択 */
    .stage-select-screen { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; }
    .stage-select-card { width: min(720px, 92vw); background: rgba(0,0,0,0.9); border-radius: 18px; padding: 24px; backdrop-filter: blur(10px); box-shadow: 0 10px 30px rgba(0,0,0,0.35); }
    .stage-select-title { font-size: 1.8rem; margin-bottom: 10px; text-align: center; background: linear-gradient(45deg, #FFD700, #FFA500); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .stage-select-sub { text-align: center; opacity: .85; margin-bottom: 14px; font-size: .95rem; }
    .stage-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }
    .stage-card { background: rgba(255,255,255,0.08); border: 1px solid rgba(255,215,0,.25); border-radius: 14px; padding: 14px; display: flex; flex-direction: column; gap: 8px; transition: transform .2s ease, box-shadow .2s ease, border-color .2s ease; }
    .stage-card:hover { transform: translateY(-2px); box-shadow: 0 6px 18px rgba(0,0,0,.35); border-color: rgba(255,215,0,.55); }
    .stage-top { display: flex; justify-content: space-between; align-items: center; }
    .stage-badge { background: rgba(255,215,0,.25); color: #FFD700; border: 1px solid #FFD700; padding: 2px 8px; border-radius: 999px; font-size: .8rem; font-weight: 700; }
    .lock-badge { background: rgba(255,255,255,.15); color: #ddd; border: 1px solid #666; }
    .stage-name { font-weight: 700; font-size: 1.05rem; }
    .stage-desc { font-size: .85rem; opacity: .9; line-height: 1.45; }
    .stage-meta { display: flex; gap: 6px; flex-wrap: wrap; font-size: .75rem; opacity: .85; }
    .stage-btn { align-self: flex-end; background: linear-gradient(45deg, #FF6B6B, #FF8E53); color: #fff; border: none; padding: 8px 14px; border-radius: 999px; cursor: pointer; font-weight: 700; box-shadow: 0 4px 12px rgba(255,107,107,.25); transition: transform .15s ease, box-shadow .15s ease, opacity .15s ease; }
    .stage-btn:hover { transform: translateY(-1px); box-shadow: 0 6px 18px rgba(255,107,107,.35); }
    .stage-btn.locked { background: linear-gradient(45deg, #666, #555); box-shadow: none; cursor: not-allowed; opacity: .6; }
    .reset-progress { margin-top: 12px; display: inline-block; font-size: .85rem; opacity: .8; text-decoration: underline; cursor: pointer; }

    .start-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0,0,0,0.9); padding: 30px 20px; border-radius: 20px; backdrop-filter: blur(10px); max-width: 90%; width: 100%; max-width: 600px; display: none; }
    h1 { font-size: 2rem; margin-bottom: 15px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); background: linear-gradient(45deg, #FFD700, #FFA500); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; }
    .subtitle { font-size: 1rem; margin-bottom: 20px; opacity: 0.9; line-height: 1.5; }
    .rules { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px; text-align: left; font-size: .85rem; line-height: 1.6; }
    .rules h3 { color: #FFD700; margin-bottom: 8px; font-size: 1rem; }
    .vocabulary-section { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin-bottom: 15px; max-height: 250px; overflow-y: auto; }
    .vocabulary-section h3 { color: #FFD700; margin-bottom: 10px; text-align: center; font-size: 1rem; }
    .word-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 8px; }
    .word-item { background: rgba(0,0,0,0.3); padding: 8px; border-radius: 6px; text-align: center; border: 1px solid rgba(255,215,0,0.3); transition: all .3s ease; }
    .word-item:hover { background: rgba(255,215,0,0.2); border-color: rgba(255,215,0,0.6); }
    .word-english { font-weight: 700; color: #FFD700; font-size: .95rem; margin-bottom: 3px; }
    .word-japanese { color: #fff; font-size: .8rem; }
    .toggle-vocabulary { background: rgba(255,215,0,0.2); color: #FFD700; border: 1px solid #FFD700; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-size: .85rem; margin-bottom: 15px; transition: all .3s ease; }
    .toggle-vocabulary:hover { background: rgba(255,215,0,0.3); }
    .start-button, .retry-button { background: linear-gradient(45deg, #FF6B6B, #FF8E53); color: #fff; border: none; padding: 12px 24px; font-size: 1.1rem; border-radius: 40px; cursor: pointer; transition: all .3s ease; box-shadow: 0 4px 15px rgba(255,107,107,0.3); }
    .start-button:hover, .retry-button:hover { transform: translateY(-2px); box-shadow: 0 6px 20px rgba(255,107,107,0.4); }

    .review-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0,0,0,0.9); padding: 30px 20px; border-radius: 20px; backdrop-filter: blur(10px); max-width: 90%; width: 100%; max-width: 600px; display: none; }
    .review-title { font-size: 1.8rem; color: #FFD700; margin-bottom: 15px; }
    .review-subtitle { font-size: 1rem; margin-bottom: 20px; opacity: .9; }
    .review-word-display { background: rgba(255,255,255,0.1); padding: 25px 15px; border-radius: 15px; margin-bottom: 15px; min-height: 100px; display: flex; flex-direction: column; justify-content: center; }
    .review-english { font-size: 2rem; color: #FFD700; font-weight: 700; margin-bottom: 8px; }
    .review-japanese { font-size: 1.3rem; color: #fff; }
    .review-progress { font-size: 1rem; margin-bottom: 15px; color: #FFD700; }
    .review-timer { width: 100%; height: 6px; background: rgba(255,255,255,0.2); border-radius: 3px; overflow: hidden; margin-bottom: 15px; }
    .review-timer-fill { height: 100%; background: linear-gradient(90deg, #FFD700, #FFA500); transition: width .1s linear; }

    .game-ui { position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(to bottom, rgba(0,0,0,0.9) 0%, rgba(0,0,0,0.7) 70%, transparent 100%); padding: 10px; z-index: 200; display: none; flex-direction: column; gap: 8px; }
    .game-stats { display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 4px; }
    .stat-item { background: rgba(0,0,0,0.8); padding: 4px 8px; border-radius: 15px; font-size: .75rem; font-weight: 700; backdrop-filter: blur(10px); white-space: nowrap; }
    .stage-display { background: rgba(255,215,0,0.3); color: #FFD700; padding: 4px 8px; border-radius: 15px; font-size: .7rem; border: 1px solid #FFD700; }
    .question-display { text-align: center; background: rgba(0,0,0,0.9); padding: 12px; border-radius: 12px; backdrop-filter: blur(10px); margin: 0 5px; }
    .question-japanese { font-size: 1.8rem; color: #FFD700; margin-bottom: 6px; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); font-weight: 700; }
    .question-instruction { font-size: .9rem; opacity: .9; margin-bottom: 8px; }
    .progress-bar { width: 100%; height: 4px; background: rgba(255,255,255,0.2); border-radius: 2px; overflow: hidden; }
    .progress-fill { height: 100%; background: linear-gradient(90deg, #4CAF50, #8BC34A); transition: width .3s ease; }
    .mistakes-indicator { display: flex; gap: 2px; align-items: center; }
    .mistake-heart { width: 16px; height: 16px; color: #FF6B6B; font-size: .9rem; }
    .mistake-heart.lost { opacity: .3; }
    .game-canvas { margin-top: 120px; height: calc(100vh - 120px); }

    .result-screen { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; background: rgba(0,0,0,0.9); padding: 30px 20px; border-radius: 20px; backdrop-filter: blur(10px); display: none; max-width: 90%; width: 100%; max-width: 500px; }
    .result-title { font-size: 2rem; margin-bottom: 15px; }
    .result-title.success { color: #4CAF50; }
    .result-title.failure { color: #FF6B6B; }
    .result-stats { background: rgba(255,255,255,0.1); padding: 15px; border-radius: 10px; margin: 15px 0; font-size: .9rem; }
    .result-message { font-size: 1rem; margin-bottom: 20px; opacity: .9; line-height: 1.4; }

    .feedback-effect { position: absolute; font-weight: 700; font-size: 1.5rem; pointer-events: none; z-index: 1000; text-shadow: 2px 2px 4px rgba(0,0,0,0.8); }
    .feedback-correct { color: #4CAF50; }
    .feedback-wrong { color: #FF6B6B; }
    @keyframes feedbackAnimation { 0%{opacity:1; transform:scale(1);} 100%{opacity:0; transform:scale(1.5) translateY(-40px);} }

    .error-message { position: fixed; top: 20px; left: 50%; transform: translateX(-50%); background: rgba(255,0,0,0.9); color: #fff; padding: 8px 16px; border-radius: 5px; font-size: .8rem; z-index: 2000; max-width: 90%; }

    @media (max-width: 768px) { .start-screen, .result-screen, .review-screen { padding: 20px 15px; width: 95%; } .question-japanese { font-size: 1.5rem; } .review-english { font-size: 1.8rem; } .game-stats { justify-content: center; } .stat-item { font-size: .7rem; padding: 3px 6px; } .question-display { padding: 10px 8px; } }
    @media (max-width: 480px) { .game-ui { padding: 8px; } .game-canvas { margin-top: 110px; height: calc(100vh - 110px); } .question-japanese { font-size: 1.3rem; } .stat-item { font-size: .65rem; } .stage-grid { grid-template-columns: repeat(2, 1fr); } }
  </style>
</head>
<body>
  <div id="gameContainer">
    <canvas id="threeCanvas"></canvas>

    <div class="ui-overlay">
      <!-- ステージ選択 -->
      <div class="stage-select-screen" id="stageSelectScreen">
        <div class="stage-select-card">
          <div class="stage-select-title">🎯 ステージを選択</div>
          <div class="stage-select-sub">クリアしたステージのみ次へ進めます（自動保存）</div>
          <div class="stage-grid" id="stageGrid"></div>
          <div class="reset-progress" id="resetProgress">進行状況をリセットする</div>
        </div>
      </div>

      <!-- スタート画面 -->
      <div class="start-screen" id="startScreen">
        <h1>🐹 3D English Learning<br />Whack-a-Mole!</h1>
        <p class="subtitle" id="stageSubtitle">日本語のお題に対応する英単語のモグラをたたこう！</p>
        <div class="rules">
          <h3>📖 ルール</h3>
          <div id="rulesBody"></div>
        </div>
        <button class="toggle-vocabulary" onclick="toggleVocabulary()">📚 出題単語を確認する</button>
        <div class="vocabulary-section" id="vocabularySection" style="display: none;">
          <h3>📚 出題される単語一覧</h3>
          <div class="word-grid" id="wordGrid"></div>
        </div>
        <button class="start-button" onclick="startGame()">学習スタート</button>
      </div>

      <!-- おさらい -->
      <div class="review-screen" id="reviewScreen">
        <div class="review-title">📚 単語おさらいタイム</div>
        <div class="review-subtitle">ゲーム前に10個の単語を確認しよう！</div>
        <div class="review-word-display" id="reviewWordDisplay">
          <div class="review-english" id="reviewEnglish">準備中...</div>
          <div class="review-japanese" id="reviewJapanese">準備中...</div>
        </div>
        <div class="review-progress" id="reviewProgress">1 / 10</div>
        <div class="review-timer"><div class="review-timer-fill" id="reviewTimerFill"></div></div>
        <div style="opacity:.7;font-size:.85rem;">各単語を発音します（タップで音声開始）</div>
      </div>

      <!-- ゲームUI -->
      <div class="game-ui" id="gameUI">
        <div class="game-stats">
          <div class="stat-item stage-display">ステージ <span id="stageDisplay">1</span></div>
          <div class="stat-item">問題: <span id="questionCount">1</span>/10</div>
          <div class="stat-item">ポイント: <span id="scoreDisplay">0</span></div>
          <div class="stat-item">目標: <span id="targetScoreDisplay">0</span></div>
          <div class="stat-item">レベル: <span id="levelDisplay">1</span></div>
          <div class="stat-item mistakes-indicator"><span>❤</span><span class="mistake-heart" id="heart1">❤</span><span class="mistake-heart" id="heart2">❤</span><span class="mistake-heart" id="heart3">❤</span></div>
        </div>
        <div class="question-display">
          <div class="question-japanese" id="questionJapanese">準備中...</div>
          <div class="question-instruction" id="questionInstruction">英語で何と言う？</div>
          <div class="progress-bar"><div class="progress-fill" id="progressFill"></div></div>
        </div>
      </div>

      <!-- 結果 -->
      <div class="result-screen" id="resultScreen">
        <div class="result-title" id="resultTitle">結果</div>
        <div class="result-stats" id="resultStats">
          <div>ステージ: <span id="completedStages">1</span>/6</div>
          <div>正解数: <span id="correctCount">0</span>/10</div>
          <div>最終ポイント: <span id="finalScore">0</span></div>
          <div>目標スコア: <span id="targetScoreLabel">0</span></div>
          <div>間違い: <span id="mistakeCount">0</span>/<span id="maxMistakesLabel">3</span></div>
          <div>到達レベル: <span id="finalLevel">1</span></div>
        </div>
        <div class="result-message" id="resultMessage">お疲れさまでした！</div>
        <button class="retry-button" onclick="backToStageSelect()">ステージ選択へ</button>
        <button class="retry-button" style="margin-left:8px;" onclick="resetGameAndReplay()">同じステージで再挑戦</button>
      </div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    /*********************** データ ************************/ 
    const wordDatabase = [
      { japanese: "犬", english: "dog" },{ japanese: "猫", english: "cat" },{ japanese: "本", english: "book" },{ japanese: "車", english: "car" },{ japanese: "家", english: "house" },{ japanese: "学校", english: "school" },{ japanese: "水", english: "water" },{ japanese: "食べ物", english: "food" },{ japanese: "時間", english: "time" },{ japanese: "友達", english: "friend" },{ japanese: "音楽", english: "music" },{ japanese: "色", english: "color" },{ japanese: "花", english: "flower" },{ japanese: "空", english: "sky" },{ japanese: "太陽", english: "sun" },{ japanese: "月", english: "moon" },{ japanese: "星", english: "star" },{ japanese: "海", english: "sea" },{ japanese: "山", english: "mountain" },{ japanese: "川", english: "river" }
    ];

    // ステージ設定（目標スコアつき）
    const STAGES = [
      null,
      { id: 1, name: 'JP → EN', promptType: 'JPtoEN', timeSec: 8, hearts: 3, targetScore: 120, desc: '日本語を英語に。基本編。' },
      { id: 2, name: 'EN → JP', promptType: 'ENtoJP', timeSec: 8, hearts: 3, targetScore: 140, desc: '英語を日本語に。方向チェンジ。' },
      { id: 3, name: 'JP → EN+', promptType: 'JPtoEN', timeSec: 7, hearts: 3, targetScore: 160, desc: '時間短縮＆出現頻度↑。' },
      { id: 4, name: 'EN → JP+', promptType: 'ENtoJP', timeSec: 6, hearts: 3, targetScore: 180, desc: 'さらにスピードアップ。' },
      { id: 5, name: 'MIX', promptType: 'MIX', timeSec: 5, hearts: 3, targetScore: 200, desc: '日本語/英語が毎問ランダム。' },
      { id: 6, name: 'MIX速', promptType: 'MIX', timeSec: 4, hearts: 2, targetScore: 220, desc: '最速チャレンジ（❤2）' }
    ];
    const STORAGE_KEY_UNLOCK = 'preglish_whack_unlock_v2';

    /*********************** 状態 ************************/
    let selectedStageId = 1;
    let stageConfig = STAGES[1];
    let gameState = {
      scene: null, camera: null, renderer: null,
      holes: [], moles: [], activeMoles: [],
      raycaster: null, mouse: null,
      currentQuestion: 0, correctAnswers: 0, mistakes: 0,
      level: 1, score: 0, isPlaying: false, stage: 1,
      isReviewTime: false, reviewWords: [], currentWord: null,
      questionTimer: null, moleSpawnTimer: null, progressTimer: null,
      questionStartTime: 0, spawnInterval: 1000, usedWords: [], currentOptions: [],
      audioContext: null, isSpeechSupported: false,
      currentPromptType: 'JPtoEN'
    };

    /*********************** 進行状況 ************************/
    function getUnlockedStage() {
      const n = parseInt(localStorage.getItem(STORAGE_KEY_UNLOCK) || '1', 10);
      return Math.min(Math.max(n, 1), 6);
    }
    function setUnlockedStage(n) {
      const current = getUnlockedStage();
      if (n > current) localStorage.setItem(STORAGE_KEY_UNLOCK, String(n));
    }

    /*********************** 音声 ************************/
    function initAudio() {
      try {
        gameState.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        gameState.isSpeechSupported = 'speechSynthesis' in window;
      } catch (e) { console.warn('Audio init failed', e); }
    }
    function playSound(type) {
      try {
        if (!gameState.audioContext) return;
        const osc = gameState.audioContext.createOscillator();
        const gain = gameState.audioContext.createGain();
        osc.connect(gain); gain.connect(gameState.audioContext.destination);
        if (type === 'correct') {
          osc.frequency.setValueAtTime(523.25, gameState.audioContext.currentTime);
          osc.frequency.setValueAtTime(659.25, gameState.audioContext.currentTime + 0.1);
          osc.frequency.setValueAtTime(783.99, gameState.audioContext.currentTime + 0.2);
          osc.type = 'triangle';
          gain.gain.setValueAtTime(0.3, gameState.audioContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, gameState.audioContext.currentTime + 0.4);
          osc.start(); osc.stop(gameState.audioContext.currentTime + 0.4);
        } else if (type === 'wrong') {
          osc.frequency.setValueAtTime(415.3, gameState.audioContext.currentTime);
          osc.frequency.setValueAtTime(311.13, gameState.audioContext.currentTime + 0.15);
          osc.type = 'sawtooth';
          gain.gain.setValueAtTime(0.2, gameState.audioContext.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, gameState.audioContext.currentTime + 0.3);
          osc.start(); osc.stop(gameState.audioContext.currentTime + 0.3);
        }
      } catch (e) { console.warn('playSound failed', e); }
    }
    function speakWord(word, cb){
      try {
        if (!gameState.isSpeechSupported) { if (cb) setTimeout(cb, 1000); return; }
        const u = new SpeechSynthesisUtterance(word);
        u.lang = 'en-US'; u.rate = 0.9; u.pitch = 1.0; u.volume = 0.9;
        const voices = speechSynthesis.getVoices();
        const pref = ['Samantha','Alex','Karen','Microsoft Zira','Google US English','en-US'];
        let v = null; for (const name of pref){ v = voices.find(x => x.name.includes(name) && x.lang.startsWith('en')); if (v) break; }
        if (!v) v = voices.find(x => x.lang === 'en-US' && x.localService);
        if (!v) v = voices.find(x => x.lang.startsWith('en-US'));
        if (v) u.voice = v;
        u.onend = () => cb && setTimeout(cb, 300);
        u.onerror = () => cb && setTimeout(cb, 1000);
        speechSynthesis.cancel(); setTimeout(()=> speechSynthesis.speak(u), 100);
      } catch(e){ console.warn('speak failed', e); if (cb) setTimeout(cb, 1000); }
    }
    function initVoices(){ if('speechSynthesis' in window){ if(speechSynthesis.getVoices().length===0){ speechSynthesis.addEventListener('voiceschanged', ()=>{}); }}}

    /*********************** ユーティリティ ************************/
    function showError(message){ console.error(message); const d=document.createElement('div'); d.className='error-message'; d.textContent='エラー: '+message; document.body.appendChild(d); setTimeout(()=>{ if(document.body.contains(d)) document.body.removeChild(d); }, 5000); }
    function clamp(v,min,max){ return Math.max(min, Math.min(max, v)); }

    /*********************** three.js 初期化 ************************/
    function init3DScene(){
      try {
        const canvas = document.getElementById('threeCanvas');
        if (!canvas) throw new Error('Canvas element not found');
        if (typeof THREE === 'undefined') throw new Error('Three.js library not loaded');
        initAudio(); initVoices();
        gameState.scene = new THREE.Scene();
        gameState.scene.background = new THREE.Color(0x87CEEB);
        gameState.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        gameState.camera.position.set(0, 10, 6); gameState.camera.lookAt(0, -1, 0);
        gameState.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        updateCanvasSize(); gameState.renderer.shadowMap.enabled = true; gameState.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        gameState.raycaster = new THREE.Raycaster(); gameState.mouse = new THREE.Vector2();
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6); gameState.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8); directionalLight.position.set(10,10,5); directionalLight.castShadow = true; directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048; gameState.scene.add(directionalLight);
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(20,20), new THREE.MeshLambertMaterial({ color: 0x3d8b37 })); ground.rotation.x = -Math.PI/2; ground.receiveShadow = true; gameState.scene.add(ground);
        createHolesAndMoles();
        canvas.addEventListener('click', onMouseClick); canvas.addEventListener('touchstart', onTouchStart); canvas.addEventListener('mousemove', onMouseMove); window.addEventListener('resize', onWindowResize);
        animate();
      } catch (e) { showError('3Dシーンの初期化に失敗しました: '+e.message); }
    }
    function updateCanvasSize(){
      const gameUI = document.getElementById('gameUI');
      const isGameScreen = gameUI && gameUI.style.display !== 'none';
      if (isGameScreen){ const uiHeight = 120; gameState.renderer.setSize(window.innerWidth, window.innerHeight - uiHeight); gameState.camera.aspect = window.innerWidth / (window.innerHeight - uiHeight); }
      else { gameState.renderer.setSize(window.innerWidth, window.innerHeight); gameState.camera.aspect = window.innerWidth / window.innerHeight; }
      gameState.camera.updateProjectionMatrix();
    }
    function createHolesAndMoles(){
      try {
        gameState.holes = []; gameState.moles = [];
        for (let i=0;i<3;i++){
          for (let j=0;j<3;j++){
            const x=(i-1)*3, z=(j-1)*3;
            const hole = new THREE.Mesh(new THREE.CylinderGeometry(0.8,0.6,0.5,16), new THREE.MeshLambertMaterial({ color: 0x4a4a4a }));
            hole.position.set(x,-0.25,z); hole.receiveShadow = true; gameState.scene.add(hole); gameState.holes.push(hole);
            const moleGroup = new THREE.Group();
            const body = new THREE.Mesh(new THREE.SphereGeometry(0.6,16,16), new THREE.MeshLambertMaterial({ color: 0x8B4513 })); body.castShadow = true; moleGroup.add(body);
            const eyeGeo = new THREE.SphereGeometry(0.1,8,8); const eyeMat = new THREE.MeshLambertMaterial({ color: 0x000000 });
            const leftEye = new THREE.Mesh(eyeGeo, eyeMat); leftEye.position.set(-0.2,0.2,0.4); moleGroup.add(leftEye);
            const rightEye = new THREE.Mesh(eyeGeo, eyeMat); rightEye.position.set(0.2,0.2,0.4); moleGroup.add(rightEye);
            moleGroup.position.set(x,-2,z);
            moleGroup.userData = { index: i*3 + j, isActive:false, targetY:0.5, hiddenY:-2, word:"", isCorrect:false };
            gameState.scene.add(moleGroup); gameState.moles.push(moleGroup);
          }
        }
      } catch(e){ showError('モグラの作成に失敗しました: '+e.message); }
    }
    function createTextTexture(text){
      try {
        const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 256;
        const ctx = canvas.getContext('2d'); if(!ctx) throw new Error('Canvas context not available');
        ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height);
        ctx.strokeStyle = '#000000'; ctx.lineWidth = 8; ctx.strokeRect(4,4,canvas.width-8,canvas.height-8);
        ctx.fillStyle = '#000000'; let fontSize = 48; ctx.font = `bold ${fontSize}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        while (ctx.measureText(text).width > canvas.width - 40 && fontSize > 20) { fontSize -= 2; ctx.font = `bold ${fontSize}px Arial`; }
        ctx.fillText(text, canvas.width/2, canvas.height/2);
        const texture = new THREE.CanvasTexture(canvas); texture.needsUpdate = true; return texture;
      } catch(e){ showError('テキストテクスチャの作成に失敗しました: '+e.message); return null; }
    }

    /*********************** ステージ選択 ************************/
    function buildStageSelect(){
      const grid = document.getElementById('stageGrid');
      grid.innerHTML = '';
      const unlocked = getUnlockedStage();
      STAGES.slice(1).forEach(cfg => {
        const card = document.createElement('div'); card.className = 'stage-card';
        const top = document.createElement('div'); top.className='stage-top';
        const badge = document.createElement('div'); badge.className = 'stage-badge'; badge.textContent = `Stage ${cfg.id}`;
        if (cfg.id > unlocked){ badge.classList.add('lock-badge'); badge.textContent += ' 🔒'; }
        const name = document.createElement('div'); name.className='stage-name'; name.textContent = cfg.name;
        top.appendChild(badge); top.appendChild(name); card.appendChild(top);
        const desc = document.createElement('div'); desc.className='stage-desc'; desc.textContent = cfg.desc; card.appendChild(desc);
        const meta = document.createElement('div'); meta.className='stage-meta'; meta.innerHTML = `⏱ ${cfg.timeSec}s / ❤ ${cfg.hearts} / 🎯 ${cfg.targetScore} / 問題数 10`; card.appendChild(meta);
        const btn = document.createElement('button'); btn.className = 'stage-btn'; btn.textContent = cfg.id > unlocked ? 'ロック中' : 'このステージで遊ぶ';
        if (cfg.id > unlocked){ btn.classList.add('locked'); }
        btn.addEventListener('click', ()=>{ if (cfg.id > unlocked) return; selectStage(cfg.id); });
        card.appendChild(btn);
        grid.appendChild(card);
      });
    }
    function selectStage(id){
      selectedStageId = id; stageConfig = STAGES[id];
      const subtitle = document.getElementById('stageSubtitle');
      const rules = document.getElementById('rulesBody');
      const dirText = stageConfig.promptType === 'JPtoEN' ? '日本語 → 英語' : (stageConfig.promptType === 'ENtoJP' ? '英語 → 日本語' : '日本語/英語 MIX');
      subtitle.textContent = `${dirText} のモグラをたたこう！（Stage ${id}）`;
      rules.innerHTML = `• ${dirText}で答える（Stage ${id}）<br>• 各ステージ10問に挑戦！<br>• お題は${stageConfig.timeSec}秒ごとに変わります<br>• 間違えると❤が減ります（${stageConfig.hearts}回でゲームオーバー）<br>• 🎯 目標スコア: <b>${stageConfig.targetScore}</b>`;
      document.getElementById('stageSelectScreen').style.display = 'none';
      document.getElementById('startScreen').style.display = 'block';
      generateWordList();
    }
    document.getElementById('resetProgress').addEventListener('click', ()=>{
      localStorage.setItem(STORAGE_KEY_UNLOCK, '1'); buildStageSelect();
    });

    /*********************** 単語UI ************************/
    function toggleVocabulary(){
      try {
        const vocabularySection = document.getElementById('vocabularySection');
        const toggleButton = document.querySelector('.toggle-vocabulary');
        if (vocabularySection.style.display === 'none'){ generateWordList(); vocabularySection.style.display = 'block'; toggleButton.textContent = '📚 単語リストを隠す'; }
        else { vocabularySection.style.display = 'none'; toggleButton.textContent = '📚 出題単語を確認する'; }
      } catch(e){ showError('単語帳表示の切り替えに失敗しました: '+e.message); }
    }
    function generateWordList(){
      try {
        const wordGrid = document.getElementById('wordGrid'); if (!wordGrid) return; wordGrid.innerHTML = '';
        wordDatabase.forEach(word => {
          const item = document.createElement('div'); item.className='word-item';
          const en = document.createElement('div'); en.className='word-english'; en.textContent = word.english;
          const ja = document.createElement('div'); ja.className='word-japanese'; ja.textContent = word.japanese;
          item.appendChild(en); item.appendChild(ja); wordGrid.appendChild(item);
        });
      } catch(e){ showError('単語リストの生成に失敗しました: '+e.message); }
    }

    /*********************** ゲーム開始フロー ************************/
    function startGame(){
      try {
        if (gameState.audioContext && gameState.audioContext.state === 'suspended') gameState.audioContext.resume();
        startReviewTime();
      } catch(e){ showError('ゲーム開始に失敗しました: '+e.message); }
    }
    function startReviewTime(){
      try {
        document.getElementById('startScreen').style.display = 'none';
        document.getElementById('reviewScreen').style.display = 'block';
        gameState.isReviewTime = true; gameState.reviewWords = wordDatabase.slice().sort(()=>Math.random()-0.5).slice(0,10);
        showReviewWord(0);
      } catch(e){ showError('おさらいタイムの開始に失敗しました: '+e.message); }
    }
    function showReviewWord(index){
      try {
        if (index >= gameState.reviewWords.length){
          document.getElementById('reviewScreen').style.display = 'none';
          document.getElementById('gameUI').style.display = 'flex';
          const canvas = document.getElementById('threeCanvas'); canvas.className = 'game-canvas'; updateCanvasSize();
          gameState.isReviewTime = false; actualStartGame(); return;
        }
        const word = gameState.reviewWords[index];
        document.getElementById('reviewEnglish').textContent = word.english;
        document.getElementById('reviewJapanese').textContent = word.japanese;
        document.getElementById('reviewProgress').textContent = `${index+1} / 10`;
        const timerFill = document.getElementById('reviewTimerFill'); timerFill.style.width = '100%';
        speakWord(word.english, ()=>{ timerFill.style.width = '0%'; setTimeout(()=> showReviewWord(index+1), 200); });
      } catch(e){ showError('おさらい単語表示に失敗しました: '+e.message); }
    }
    function actualStartGame(){
      try {
        gameState.currentQuestion = 0; gameState.correctAnswers = 0; gameState.mistakes = 0;
        gameState.level = 1; gameState.score = 0; gameState.stage = selectedStageId; gameState.isPlaying = true;
        gameState.usedWords = []; gameState.spawnInterval = 1000; gameState.activeMoles = [];
        for (let i=1;i<=3;i++){ const h = document.getElementById(`heart${i}`); if (h) h.classList.remove('lost'); }
        const maxMist = document.getElementById('maxMistakesLabel'); if (maxMist) maxMist.textContent = stageConfig.hearts;
        if (stageConfig.hearts < 3){ for (let i=stageConfig.hearts+1;i<=3;i++){ const h=document.getElementById(`heart${i}`); if (h) h.classList.add('lost'); } }
        const tgt = document.getElementById('targetScoreDisplay'); if (tgt) tgt.textContent = stageConfig.targetScore;
        gameState.moles.forEach(m => { if (m && m.userData){ m.userData.isActive=false; clearMoleText(m); }});
        updateMistakesDisplay(); generateQuestion();
      } catch(e){ showError('実際のゲーム開始に失敗しました: '+e.message); }
    }

    /*********************** 出題 ************************/
    function choosePromptTypeForQuestion(){
      if (stageConfig.promptType === 'MIX'){
        gameState.currentPromptType = Math.random() < 0.5 ? 'JPtoEN' : 'ENtoJP';
      } else {
        gameState.currentPromptType = stageConfig.promptType;
      }
      return gameState.currentPromptType;
    }
    function updateQuestionDisplay(correctWord){
      try {
        const qEl = document.getElementById('questionJapanese');
        const qCount = document.getElementById('questionCount');
        const levelEl = document.getElementById('levelDisplay');
        const scoreEl = document.getElementById('scoreDisplay');
        const stageEl = document.getElementById('stageDisplay');
        const instruction = document.getElementById('questionInstruction');
        const mode = gameState.currentPromptType;
        if (mode === 'JPtoEN'){ qEl.textContent = correctWord.japanese; instruction.textContent = '英語で何と言う？'; }
        else { qEl.textContent = correctWord.english; instruction.textContent = '日本語で何と言う？'; }
        if (qCount) qCount.textContent = gameState.currentQuestion + 1;
        if (levelEl) levelEl.textContent = gameState.level;
        if (scoreEl) scoreEl.textContent = gameState.score;
        if (stageEl) stageEl.textContent = gameState.stage;
      } catch(e){ showError('問題表示更新に失敗しました: '+e.message); }
    }
    function generateQuestion(){
      try {
        if (gameState.currentQuestion >= 10){ finishStageByScore(); return; }
        let available = wordDatabase.filter(w => !gameState.usedWords.includes(w));
        if (available.length === 0){ gameState.usedWords = []; available = wordDatabase.slice(); }
        const correctWord = available[Math.floor(Math.random()*available.length)];
        gameState.usedWords.push(correctWord); gameState.currentWord = correctWord;
        const incorrect = wordDatabase.filter(w => w !== correctWord).sort(()=>Math.random()-0.5);
        gameState.currentOptions = [correctWord, correctWord, correctWord, incorrect[0], incorrect[1], incorrect[2]];
        choosePromptTypeForQuestion();
        updateQuestionDisplay(correctWord);
        startProgressBar();
        startContinuousMoleSpawning();
        if (gameState.questionTimer) clearTimeout(gameState.questionTimer);
        gameState.questionTimer = setTimeout(()=>{ nextQuestion(); }, stageConfig.timeSec * 1000);
        gameState.questionStartTime = Date.now();
      } catch(e){ showError('問題生成に失敗しました: '+e.message); }
    }
    function startProgressBar(){
      try {
        const fill = document.getElementById('progressFill'); if(!fill) return; fill.style.width = '100%';
        let progress = 100; if (gameState.progressTimer) clearInterval(gameState.progressTimer);
        const step = 100 / (stageConfig.timeSec * 10); // 0.1s刻み
        gameState.progressTimer = setInterval(()=>{ progress -= step; fill.style.width = Math.max(0, progress) + '%'; if (progress <= 0){ clearInterval(gameState.progressTimer); } }, 100);
      } catch(e){ showError('プログレスバーの開始に失敗しました: '+e.message); }
    }
    function startContinuousMoleSpawning(){
      try { if (gameState.moleSpawnTimer) clearTimeout(gameState.moleSpawnTimer); spawnSingleMole(); } catch(e){ showError('連続モグラ出現の開始に失敗しました: '+e.message); }
    }
    function spawnSingleMole(){
      try {
        if (!gameState.isPlaying) return;
        const randomWord = gameState.currentOptions[Math.floor(Math.random()*gameState.currentOptions.length)];
        const availableHoles = []; for (let i=0;i<9;i++){ if (!gameState.activeMoles.includes(i)) availableHoles.push(i); }
        if (availableHoles.length > 0){
          const holeIndex = availableHoles[Math.floor(Math.random()*availableHoles.length)];
          const mole = gameState.moles[holeIndex]; setMoleText(mole, randomWord); mole.userData.isActive = true; gameState.activeMoles.push(holeIndex);
          const visibleTime = clamp(1500 - (selectedStageId-1)*150 + Math.random()*600, 700, 2200);
          setTimeout(()=>{ if (mole.userData && mole.userData.isActive){ mole.userData.isActive = false; gameState.activeMoles = gameState.activeMoles.filter(i=>i!==holeIndex); clearMoleText(mole); } }, visibleTime);
        }
        const nextSpawnTime = clamp(600 - (selectedStageId-1)*60 + Math.random()*400, 200, 900);
        if (gameState.isPlaying) gameState.moleSpawnTimer = setTimeout(spawnSingleMole, nextSpawnTime);
      } catch(e){ showError('モグラ出現に失敗しました: '+e.message); }
    }
    function setMoleText(mole, wordObj){
      try {
        clearMoleText(mole);
        if (gameState.currentPromptType === 'JPtoEN'){ mole.userData.word = wordObj.english; mole.userData.isCorrect = (wordObj === gameState.currentWord); }
        else { mole.userData.word = wordObj.japanese; mole.userData.isCorrect = (wordObj === gameState.currentWord); }
        const tex = createTextTexture(mole.userData.word); if (tex){ const mesh = new THREE.Mesh(new THREE.PlaneGeometry(3,1.5), new THREE.MeshBasicMaterial({ map: tex, transparent: true, alphaTest: .1 })); mesh.position.set(0,1.2,0); mesh.lookAt(gameState.camera.position); mesh.name='textMesh'; mole.add(mesh); }
      } catch(e){ showError('モグラテキスト設定に失敗しました: '+e.message); }
    }
    function clearMoleText(mole){ try { const t = mole.getObjectByName('textMesh'); if (t) mole.remove(t); mole.userData.word = ""; mole.userData.isCorrect = false; } catch(e){ console.error('モグラテキストクリアエラー:', e); } }
    function nextQuestion(){
      try {
        if (gameState.progressTimer) clearInterval(gameState.progressTimer);
        if (gameState.moleSpawnTimer) clearTimeout(gameState.moleSpawnTimer);
        gameState.moles.forEach(m => { if (m && m.userData){ m.userData.isActive=false; clearMoleText(m); }});
        gameState.activeMoles = [];
        gameState.currentQuestion++; gameState.level = Math.floor(gameState.currentQuestion/2) + 1;
        if (gameState.currentQuestion >= 10){ finishStageByScore(); return; }
        setTimeout(()=>{ if (gameState.isPlaying) generateQuestion(); }, 400);
      } catch(e){ showError('次の問題への移行に失敗しました: '+e.message); }
    }

    /*********************** 入力 ************************/
    function onMouseClick(event){
      try {
        if (!gameState.isPlaying || !gameState.raycaster || !gameState.mouse) return;
        const rect = gameState.renderer.domElement.getBoundingClientRect();
        gameState.mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        gameState.mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        gameState.raycaster.setFromCamera(gameState.mouse, gameState.camera);
        const hits = gameState.raycaster.intersectObjects(gameState.scene.children, true);
        if (hits.length > 0){
          for (let h of hits){ const mole = h.object.parent; if (mole && mole.userData && mole.userData.isActive && mole.userData.word){ hitMole(mole.userData.index); break; } }
        }
      } catch(e){ showError('クリック処理に失敗しました: '+e.message); }
    }
    function onTouchStart(e){
      try { e.preventDefault(); if (gameState.audioContext && gameState.audioContext.state === 'suspended') gameState.audioContext.resume(); if (e.touches.length>0){ const t=e.touches[0]; onMouseClick({ clientX:t.clientX, clientY:t.clientY }); } } catch(e2){ showError('タッチ処理に失敗しました: '+e2.message); }
    }
    function hitMole(index){
      try {
        const mole = gameState.moles[index]; if (!mole || !mole.userData || !mole.userData.isActive) return;
        mole.userData.isActive = false; gameState.activeMoles = gameState.activeMoles.filter(i=>i!==index);
        if (mole.userData.isCorrect){
          gameState.correctAnswers++; const base=10, levelBonus=gameState.level*5; const pts = base+levelBonus; gameState.score += pts;
          const sEl=document.getElementById('scoreDisplay'); if(sEl) sEl.textContent = gameState.score;
          playSound('correct'); showFeedback(mole.position, `+${pts}`, 'correct');
        } else {
          gameState.mistakes++; const penalty=5; gameState.score = Math.max(0, gameState.score - penalty);
          const sEl=document.getElementById('scoreDisplay'); if(sEl) sEl.textContent = gameState.score;
          playSound('wrong'); updateMistakesDisplay(); showFeedback(mole.position, `-${penalty}`, 'wrong');
          if (gameState.mistakes >= stageConfig.hearts){ endGame(false); return; }
        }
      } catch(e){ showError('モグラヒット処理に失敗しました: '+e.message); }
    }
    function showFeedback(pos, text, type){
      try {
        const v = pos.clone().project(gameState.camera); const x = (v.x*0.5+0.5)*window.innerWidth; const y = (v.y*-0.5+0.5)*window.innerHeight + 120;
        const el = document.createElement('div'); el.className = `feedback-effect feedback-${type}`; el.textContent = text; el.style.left = x+'px'; el.style.top = y+'px'; el.style.animation = 'feedbackAnimation 1.5s ease-out forwards'; document.body.appendChild(el); setTimeout(()=>{ if(document.body.contains(el)) document.body.removeChild(el); }, 1500);
      } catch(e){ console.error('フィードバック表示エラー:', e); }
    }
    function updateMistakesDisplay(){ try { for (let i=1;i<=3;i++){ const h=document.getElementById(`heart${i}`); if (!h) continue; if (i <= gameState.mistakes) h.classList.add('lost'); else if (i <= stageConfig.hearts) h.classList.remove('lost'); } } catch(e){ showError('間違い表示の更新に失敗しました: '+e.message); } }
    function onMouseMove(e){ try { if (e.buttons===1){ const dx = e.movementX*0.01, dy = e.movementY*0.01; gameState.camera.position.x += dx; gameState.camera.position.y -= dy; gameState.camera.lookAt(0,-1,0); } } catch(e2){ console.error('マウス移動エラー:', e2); } }
    function onWindowResize(){ try { if (gameState.camera && gameState.renderer) updateCanvasSize(); } catch(e){ console.error('リサイズエラー:', e); } }

    function animate(){ try { requestAnimationFrame(animate); if (gameState.moles && gameState.moles.length>0){ gameState.moles.forEach(m => { if (m && m.userData){ const ty = m.userData.isActive ? m.userData.targetY : m.userData.hiddenY; const cy = m.position.y; const sp = 0.15; if (Math.abs(cy-ty)>0.01) m.position.y += (ty-cy)*sp; const tm = m.getObjectByName('textMesh'); if (tm && gameState.camera) tm.lookAt(gameState.camera.position); } }); } if (gameState.renderer && gameState.scene && gameState.camera){ gameState.renderer.render(gameState.scene, gameState.camera); } } catch(e){ console.error('アニメーションループエラー:', e); } }

    /*********************** スコア判定・終了 ************************/
    function finishStageByScore(){
      try {
        document.getElementById('targetScoreLabel').textContent = stageConfig.targetScore;
        if (gameState.score >= stageConfig.targetScore){ endGame(true); }
        else { endGame(false); }
      } catch(e){ showError('スコア判定に失敗しました: '+e.message); }
    }
    function endGame(isSuccess){
      try {
        gameState.isPlaying = false;
        if (gameState.questionTimer){ clearTimeout(gameState.questionTimer); gameState.questionTimer=null; }
        if (gameState.moleSpawnTimer){ clearTimeout(gameState.moleSpawnTimer); gameState.moleSpawnTimer=null; }
        if (gameState.progressTimer){ clearInterval(gameState.progressTimer); gameState.progressTimer=null; }
        if (gameState.moles){ gameState.moles.forEach(m => { if (m && m.userData){ m.userData.isActive=false; clearMoleText(m); }}); } gameState.activeMoles = [];
        document.getElementById('gameUI').style.display='none'; document.getElementById('resultScreen').style.display='block';
        const canvas=document.getElementById('threeCanvas'); canvas.className=''; updateCanvasSize();
        const title = document.getElementById('resultTitle'); const msg = document.getElementById('resultMessage');
        document.getElementById('correctCount').textContent = gameState.correctAnswers;
        document.getElementById('mistakeCount').textContent = gameState.mistakes;
        document.getElementById('finalLevel').textContent = gameState.level;
        document.getElementById('finalScore').textContent = gameState.score;
        document.getElementById('completedStages').textContent = selectedStageId;
        document.getElementById('targetScoreLabel').textContent = stageConfig.targetScore;
        if (isSuccess){
          title.textContent = '🎉 ステージクリア！'; title.className='result-title success';
          msg.textContent = `Stage ${selectedStageId} をクリア！次のステージに進めます。`;
          setUnlockedStage(selectedStageId+1);
        } else {
          title.textContent='💔 ゲームオーバー'; title.className='result-title failure';
          msg.textContent = `目標スコア ${stageConfig.targetScore} に届きませんでした…！もう一度挑戦しよう。`;
        }
        buildStageSelect(); // アンロック反映
      } catch(e){ showError('ゲーム終了処理に失敗しました: '+e.message); }
    }
    function resetGameAndReplay(){
      try {
        document.getElementById('resultScreen').style.display='none';
        document.getElementById('startScreen').style.display='block';
        const canvas=document.getElementById('threeCanvas'); canvas.className=''; updateCanvasSize();
        selectStage(selectedStageId);
      } catch(e){ showError('リトライ準備に失敗しました: '+e.message); }
    }
    function backToStageSelect(){
      try {
        document.getElementById('resultScreen').style.display='none';
        document.getElementById('stageSelectScreen').style.display='flex';
        const canvas=document.getElementById('threeCanvas'); canvas.className=''; updateCanvasSize();
      } catch(e){ showError('ステージ選択へ戻る処理に失敗しました: '+e.message); }
    }

    /*********************** 初期化 ************************/
    window.addEventListener('load', ()=>{
      try {
        initVoices();
        setTimeout(()=>{ init3DScene(); buildStageSelect(); }, 100);
      } catch(e){ showError('初期化に失敗しました: '+e.message); }
    });
    window.addEventListener('error', (event)=>{ showError('JavaScript エラー: '+event.message); });
  </script>
</body>
</html>
